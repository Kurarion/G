package chapter4

import "fmt"

//常量是使用const 定义的
//与Java不同(final)

//常量用于存储不会改变的数据
//存储在常量中的数据类型只可以是 布尔型，数字型（整数型，浮点和复数）和字符串型
//常量的定义的格式是 const identifier [type] = value
const Pi = 3.14159
//注意：常量可以不被使用，即Unused 合法
//在Go语言中，你可以省略类型说明符[type]因为编译器可以根据变量的值来推断其类型
//显式类型定义
//const b string = "abc"
//隐式类型定义
//const b = "abc"

var a = 5
//var a int = 5 //等价
//但变量就不行，必须使用
//一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需具备的类型
//也就是说，未定义类型的常量会在必要时刻根据上下文来获得相关类型
//f(n+5) //无类型的数字型常量"5"它的类型在这里变成了int

//常量的值必须是能够在编译时就能确定的；可以在其赋值表达式中涉及计算过程
//但是所有用于计算的值必须在编译期间能获得
//const c1 = 2/3 //正确
//const c2 = getNumber() //错误：
//注意：因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数 可以使用，如：len()

//数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出
//const Ln2= 0.69314718055994530941723212148\
//176568075500134360255254120680009
//事实证明使用\不能在常量表达式作为多行连接符使用
//与各种类型的数字型变量相比，无需担心常量之间的类型转换问题，因为是非常理想的数字（任何精度）
//不过需要注意：当常量赋值给一个精确度过小的数字型变量时，可能 会因为无法正确表达常量所代表的数值
//而导致溢出，这会在编译期间就引发错误，另外常量也可以使用并行赋值的形式
const beef, two , ccc = "eat", 2 , "veg"
//也可因式分解 或 可用于枚举
const(
	Unkown = 0
	female = 1
	Male = 2
	//ddd,cccc = 1,3 //可以同时赋值
)
//上面这个枚举为例子
//iota可以被用作枚举值
const(
	f = iota //0
	g = iota //1
	h = iota //2
)
//第一个iota等于0 每当iota在新的一行被使用时，它的值就会自动加1
//所以可以简写为下面
const(
	j = iota + 3 //0+3 3
	k //1+3 4
	o //2+3 5
	l = iota//3
)
//这里只是粗讲...
//iota也可以用在表达式中，如iota + 50 在每遇到一个新的常量块或单个常量声明时
//iota都会被重置为0 （注意：简单地说：就是每遇到一个const关键字时，就会重置0）
//常量如果试图修改就会引发编译错误
//
//也可以使用某个类型作为枚举常量的类型：
type Color int
const(
	RED Color = iota //0
	ORANGE //1
	YELLOW //2
)

func TestConst(){
	//fmt 的Print方法会在连续的数字型参数之间插入空格
	fmt.Println("变量","名",0,1,1.2,1.3,j,k,"=",o,l);
	fmt.Print("变量","名",0,1,1.2,1.3,j,k,"=",o,l);
	fmt.Println()

}


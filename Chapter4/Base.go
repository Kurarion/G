//这是简要注释
//
//这是详细的段注释。。。。。。。。。。。。。。。。。。。。。。
//。。。。。。。。
package chapter4

import "fmt"

//go代码中几乎所有东西都有一个名称或标识符
//Go是区分大小写的，有效的标识符必须以字母（注意：可以使用任何UTF-8编码的字符或_）
//开头，然后紧跟着0个或多个字符或Unicode数字
//例如：өԑ12，_x23 等等
//同样不能使用Go的关键字来命名
//在Go中 _是一个特殊的标识符，称为空白标识符
//可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给他）
//但赋给这个标识符的值都将被抛弃，这些值不会在后续代码中使用，也不能使用_作为变量对其他变量赋值
//
//在编码过程中，可能会遇到没有名称的变量，类型或方法，这些变量统称为匿名变量
//Go代码中会使用到的25个关键字或保留字（简化编译过程中的代码解析）
//
//程序中可能用到的标点符号有. , ; : ...

//注意：程序的代码通过语句来实现结构化，每个语句不需要像C家庭一样以;结尾这些工作由Go编译器自动完成
//如果你打算将多个语句写在同一行，则必须使用;人为区分，但不推荐
//

//===4.2===
//包是结构化代码的一种方式：每个程序都由包(pkg)的概念组成，可以使用自身的包或从其他包中导入内容
//如同其他一些编程语言中的类库或命名空间的概念，每个Go文件都属于且仅属于一个包
//一个包可以由许多以.go为扩展名的源文件组成，因此文件名与包名一般来说都是不同的

//注意：必须在源文件的非注释的第一行指明这个文件属于哪个包，第一行可以是一个注释
//注意：package main表示一个独立执行的程序，每个Go应用程序都包含一个名为main的包
//如果你打算编译的包名不是main的源文件，如pack1，则编译后产生的对象文件将会是pack1.a而不是可执行程序
//另外需要注意包名应该使用小写字母

//标准库
//在GO的安装文件里包含了一些可以直接使用的包，即标准库，在Windows下标准库的位置在Go根目录下的子目录pkg\windows_386中
//在linux下为pkg\linux_amd64中
//标准库包含了大量的包 如fmt和os，但也可以创建自己的包
//如果想要 构建一个程序，则包和包内的文件都必须以正确的顺序进行编译，包的依赖关系决定了其构建的顺序
//属于同一个包的源文件必须全部被一下编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包，
//注意这个规定是死的，否则无法通过编译

//如果对一个包进行更改或重新编译，所有引用了穿上包的客户端程序都必须全部重新编译
//Go中的包模型采用了显示依赖关系的机制来达到快速编译的目的
//编译器会从后缀名为.o的对象文件（需要且只需要这个 文件）中提取传递依赖类型的信息
//a.go -> b.go -> c.go  （依赖）
//则编译c.go, b.go 最后是a.go
//为了编译a.go 编译器读取的是b.o而不是c.o
//注意：每一段代码只会被编译一次
//一个Go程序是通过import关键字将一组包链接在一起
//包名被封闭在半角双引号""中，如果
//打算从已编译的包中导入并加载分开声明的方法，则不需要插入已编译包的源代码
//import "fmt"
//import "os"
//或
//import "fmt";import "os"
//还可以用因式分解关键字（同样适用于const var 和 type的声明或定义）
//import(
//	"fmt"
//	"os"
//)
//甚至可以更短，但使用gofmt后将会被强制换行
//import ("fmt";"os")

//注意如果包名不是以.或/开头，如"fmt"或"container/list"则Go会在全局文件进行查找
//如果包名以./开头。则Go会在相对目录中查找，如果包名以/开头，则会在系统的绝对路径中查找

//导入包即等同于包含了这个包的所有的代码对象
//一个.a就是一个独立的包os目录下有三个.a代表三个不同的包
//除了符号_，包中所有的代码对象的标识符必须是唯一的，但相同的标识符可以在不同的包中使用，因为可以使用包名来区别
//包通过下面被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件
//===可见性规则===
//当标识符（包括常量，变量，类型，函数名，结构字段等）以一个大写字母开头
//如：Group1那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包）
//这被称为 “导出”类似面向对象语言中的public;
//标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的(private)

//大写字母可以使用任何Unicode编码的字符，比如希腊文，而不仅仅是ASCII码中的大写字母
//因此在导入一个外部包后只能访问包中的的导出对象
//假设在包pack1中有一个变量Thing 则可以使用点标记来调用 pack1.Thing
//因此包也可以作为命名空间使用，帮助避免命名冲突
//两个包中的同名变量区别在于他们的包名，例如： pack1.Thing 和 pack2.Thing
//
//也可以通过包的别名来解决包名之间的名称冲突。自己的包名与别人的包名一样
//例如：
//import gm "fmt"
//调用时就变成了 gm.Println("")

//注意：如果你导入了一个包却没有使用它，则会在构建程序时引发错误
//这是 “没有不必要的代码的原则”
//

//包的分级声明和初始化
//在import导入包之后定义或声明0个或多个常量(const) 变量(var) 和类型(type)
//这些对象的作用域都是全局的，在本包的范围内，所以可以被本包中所有的函数调用
//然后声明一个或多个函数（func）

var c = "变量"

//这是定义一个函数最简单的方式
//func funcName()//但实际不能通过编译，缺少函数体
//在括号内可以写入参数，与C++等不同，参数的类型在后面

//注意：main函数是每一个可执行程序所必须包含的，一般来说都是在启动后的第一个执行函数
//（如果有(init())函数则会先执行init函数)如果你的main包的源代码中没有包含main函数，
//则会引发构建错误, main函数既没有参数也没有返回类型【与c正好相反，C++中也有void返回声明的main】
//一旦main执行完程序 就完成了执行并退出

//注意：Go中函数的函数体的左大括号必须与方法的声明放在同一行，这是编译器的强制规定
//否则就会报错
//注意：原因是会产生 func main() ;这样的结果
//Go语言虽然不要求用户书写；但实际这一过程是由编译器自动完成的，因此会造成上述问题
//右大括号需要放在紧接函数体的下一行，如果 函数非常短，可以放在同一行

func tttt(a,b int) int{ return a+b}
//对于所有大括号{}的使用规则在任何时候都是相同的(如if语句)
// func functionName(paramter_list) (return_value_list)
//参数列表： param1 type1, param2 type2,...
//返回列表： ret1 type1, ret2 type2,...

//使用fmt.Print(arr)如果没有特别指定，它们会以默认的打印格式将变量arr输出到控制台
//单纯地打印一个字符串或变量甚至可以使用【预定义的方法】实现
//如print println print("AAA") println("ABC") println(i)
//这些函数只可用于【调试阶段】，在部署程序的时候务必替换成fmt中的相关函数

//当被调用函数的代码执行到结束符}或返回语句时会返回，然后程序继续执行调用函数的之后 的代码
//程序一些资料退出的代码为0 否则非0，但main函数是没有返回列表的

//注释不会被编译，但可以通过godoc来使用
//与C++的注释规则一样

//在包 package语句之前的块注释被默认认为是这个包的文档说明，其中应该提供一些相关
//信息并对整体功能做简要的介绍，一个包可以分散在多个文件中，但是只需要在其中一个进行注释即可
//当开发人员需要了解包的一些情况时，自然会用godoc来显示包的文档说明
//在首行的简要注释之后 可以用成段的注释进行更详细的说明
//在多段注释之间应当以空行分隔加以区分

//几乎所有全局作用域类型 常量 变量函数和被导出的对象都应该有一个合理的注释
//例如函数Abcd 则要以Abcd作为开头
//TestBase 是一个测试用的函数
//它的功能很少
func TestBase() {
	fmt.Println("Test"+c)


}

//类型（或常量）包含数据，数据可以有不同的数据类型，简称类型
//使用var声明的变量的值会自动初始化为该类型的零值，类型定义了某个变量的值 的集合
//与可对其进行操作的集合


//这是简要注释
//
//这是详细的段注释。。。。。。。。。。。。。。。。。。。。。。
//。。。。。。。。
package chapter4

import "fmt"

//go代码中几乎所有东西都有一个名称或标识符
//Go是区分大小写的，有效的标识符必须以字母（注意：可以使用任何UTF-8编码的字符或_）
//开头，然后紧跟着0个或多个字符或Unicode数字
//例如：өԑ12，_x23 等等
//同样不能使用Go的关键字来命名
//在Go中 _是一个特殊的标识符，称为空白标识符
//可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给他）
//但赋给这个标识符的值都将被抛弃，这些值不会在后续代码中使用，也不能使用_作为变量对其他变量赋值
//
//在编码过程中，可能会遇到没有名称的变量，类型或方法，这些变量统称为匿名变量
//Go代码中会使用到的25个关键字或保留字（简化编译过程中的代码解析）
//
//程序中可能用到的标点符号有. , ; : ...

//注意：程序的代码通过语句来实现结构化，每个语句不需要像C家庭一样以;结尾这些工作由Go编译器自动完成
//如果你打算将多个语句写在同一行，则必须使用;人为区分，但不推荐
//

//===4.2===
//包是结构化代码的一种方式：每个程序都由包(pkg)的概念组成，可以使用自身的包或从其他包中导入内容
//如同其他一些编程语言中的类库或命名空间的概念，每个Go文件都属于且仅属于一个包
//一个包可以由许多以.go为扩展名的源文件组成，因此文件名与包名一般来说都是不同的

//注意：必须在源文件的非注释的第一行指明这个文件属于哪个包，第一行可以是一个注释
//注意：package main表示一个独立执行的程序，每个Go应用程序都包含一个名为main的包
//如果你打算编译的包名不是main的源文件，如pack1，则编译后产生的对象文件将会是pack1.a而不是可执行程序
//另外需要注意包名应该使用小写字母

//标准库
//在GO的安装文件里包含了一些可以直接使用的包，即标准库，在Windows下标准库的位置在Go根目录下的子目录pkg\windows_386中
//在linux下为pkg\linux_amd64中
//标准库包含了大量的包 如fmt和os，但也可以创建自己的包
//如果想要 构建一个程序，则包和包内的文件都必须以正确的顺序进行编译，包的依赖关系决定了其构建的顺序
//属于同一个包的源文件必须全部被一下编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包，
//注意这个规定是死的，否则无法通过编译

//如果对一个包进行更改或重新编译，所有引用了穿上包的客户端程序都必须全部重新编译
//Go中的包模型采用了显示依赖关系的机制来达到快速编译的目的
//编译器会从后缀名为.o的对象文件（需要且只需要这个 文件）中提取传递依赖类型的信息
//a.go -> b.go -> c.go  （依赖）
//则编译c.go, b.go 最后是a.go
//为了编译a.go 编译器读取的是b.o而不是c.o
//注意：每一段代码只会被编译一次
//一个Go程序是通过import关键字将一组包链接在一起
//包名被封闭在半角双引号""中，如果
//打算从已编译的包中导入并加载分开声明的方法，则不需要插入已编译包的源代码
//import "fmt"
//import "os"
//或
//import "fmt";import "os"
//还可以用因式分解关键字（同样适用于const var 和 type的声明或定义）
//import(
//	"fmt"
//	"os"
//)
//甚至可以更短，但使用gofmt后将会被强制换行
//import ("fmt";"os")

//注意如果包名不是以.或/开头，如"fmt"或"container/list"则Go会在全局文件进行查找
//如果包名以./开头。则Go会在相对目录中查找，如果包名以/开头，则会在系统的绝对路径中查找

//导入包即等同于包含了这个包的所有的代码对象
//一个.a就是一个独立的包os目录下有三个.a代表三个不同的包
//除了符号_，包中所有的代码对象的标识符必须是唯一的，但相同的标识符可以在不同的包中使用，因为可以使用包名来区别
//包通过下面被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件
//===可见性规则===
//当标识符（包括常量，变量，类型，函数名，结构字段等）以一个大写字母开头
//如：Group1那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包）
//这被称为 “导出”类似面向对象语言中的public;
//标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的(private)

//大写字母可以使用任何Unicode编码的字符，比如希腊文，而不仅仅是ASCII码中的大写字母
//因此在导入一个外部包后只能访问包中的的导出对象
//假设在包pack1中有一个变量Thing 则可以使用点标记来调用 pack1.Thing
//因此包也可以作为命名空间使用，帮助避免命名冲突
//两个包中的同名变量区别在于他们的包名，例如： pack1.Thing 和 pack2.Thing
//
//也可以通过包的别名来解决包名之间的名称冲突。自己的包名与别人的包名一样
//例如：
//import gm "fmt"
//调用时就变成了 gm.Println("")

//注意：如果你导入了一个包却没有使用它，则会在构建程序时引发错误
//这是 “没有不必要的代码的原则”
//

//包的分级声明和初始化
//在import导入包之后定义或声明0个或多个常量(const) 变量(var) 和类型(type)
//这些对象的作用域都是全局的，在本包的范围内，所以可以被本包中所有的函数调用
//然后声明一个或多个函数（func）

var c = "变量"

//这是定义一个函数最简单的方式
//func funcName()//但实际不能通过编译，缺少函数体
//在括号内可以写入参数，与C++等不同，参数的类型在后面

//注意：main函数是每一个可执行程序所必须包含的，一般来说都是在启动后的第一个执行函数
//（如果有(init())函数则会先执行init函数)如果你的main包的源代码中没有包含main函数，
//则会引发构建错误, main函数既没有参数也没有返回类型【与c正好相反，C++中也有void返回声明的main】
//一旦main执行完程序 就完成了执行并退出

//注意：Go中函数的函数体的左大括号必须与方法的声明放在同一行，这是编译器的强制规定
//否则就会报错
//注意：原因是会产生 func main() ;这样的结果
//Go语言虽然不要求用户书写；但实际这一过程是由编译器自动完成的，因此会造成上述问题
//右大括号需要放在紧接函数体的下一行，如果 函数非常短，可以放在同一行

func tttt(a,b int) int{ return a+b}
//对于所有大括号{}的使用规则在任何时候都是相同的(如if语句)
// func functionName(paramter_list) (return_value_list)
//参数列表： param1 type1, param2 type2,...
//返回列表： ret1 type1, ret2 type2,...

//使用fmt.Print(arr)如果没有特别指定，它们会以默认的打印格式将变量arr输出到控制台
//单纯地打印一个字符串或变量甚至可以使用【预定义的方法】实现
//如print println print("AAA") println("ABC") println(i)
//这些函数只可用于【调试阶段】，在部署程序的时候务必替换成fmt中的相关函数

//当被调用函数的代码执行到结束符}或返回语句时会返回，然后程序继续执行调用函数的之后 的代码
//程序一些资料退出的代码为0 否则非0，但main函数是没有返回列表的

//注释不会被编译，但可以通过godoc来使用
//与C++的注释规则一样

//在包 package语句之前的块注释被默认认为是这个包的文档说明，其中应该提供一些相关
//信息并对整体功能做简要的介绍，一个包可以分散在多个文件中，但是只需要在其中一个进行注释即可
//当开发人员需要了解包的一些情况时，自然会用godoc来显示包的文档说明
//在首行的简要注释之后 可以用成段的注释进行更详细的说明
//在多段注释之间应当以空行分隔加以区分

//几乎所有全局作用域类型 常量 变量函数和被导出的对象都应该有一个合理的注释
//例如函数Abcd 则要以Abcd作为开头
//TestBase 是一个测试用的函数
//它的功能很少
func TestBase() {
	fmt.Println("Test"+c)


}

//类型（或常量）包含数据，数据可以有不同的数据类型，简称类型
//使用var声明的变量的值会自动初始化为该类型的零值(不同于C++)，类型定义了某个变量的值 的集合
//与可对其进行操作的集合

//类型可以是基本类型，如int float bool string 结构化的（复合的），如
//struct array slice map channel
//只描述类型的行为 如 interface
//结构化的类型没有真正的值，它使用nil作为默认值
//注意：在Objective-C是nil 在Java中是null 在c与C++中是NULL或0

//注意在Go语言中是不存在类型继承的
//函数也可以是一个确定的类型，就是以函数作为返回类型，这种类型的声明要写在函数名和可选
//的参数列表之后
//例如
//func FunctionName(a typea, b typeb) typeFunc
//可以返回类型是typeFunc的类型的变量
func testReturnFuncVar() func ( int, string)(re_a int,re_b string){
	//注意不同与C++一样
	//不能直接使用普通变量声明方式创建一个函数类型的变量
	//func ret ( int, string)( int, string){return 1,""} //错误
	//上述错误的原因是在Go变量的声明是
	//var name type
	//在域内可以将声明与初始化放在一起 使用:=
	//name := ???
	//========
	//ret := func ( int, string)( int, string){return 1,""} //正确
	//正确的是
	var ret3 func ( int, string)( int, string)
	ret3  = func ( a int, b string)( re_a int, re_b string){
		re_a = a
		re_b = b
		//可以直接使用声明中的返回的标识符（不需要再次声明）
		//并且返回时只需要return即可
		return
	}
	//或使用“别名”
	type fff func (int,string)(int,string)
	//var ret2 fff = func ( int, string)( int, string){return 1,""} //正确
	//对于多个返回值的函数，返回值之间使用，分割
	//这种多返回值的一般用于判断某个函数是否成功执行或与其他返回值一同返回错误信息
	return ret3
}
//
//使用type关键字可以定义自己的类型，可能想要定义一个结构体，但是也可以定义一个已经存在类型的别名
//例如type IZ int
//注意：这不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特征
//且在类型转换时必须显式转换
//var a IZ = 5
//这里因为Int是变量a的底层类型，使得它们之间存在相互转换的可能

//如果相要多个同时定义，可以使用因式分解关键字的方式
type(
	IZ int
	FZ float64
	STR string
)
//每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值 的类型）
//Go是一种静态类型语言

//Go程序的一般结构
//编译器不关心main函数在前还是变量的声明在前
//但使用统一的结构能够有更好体验
//1。在完成包的import之后，开始对常量变量和类型的定义或声明
//2。如果存在init函数，则对此函数进行定义（每个含有该函数的包都会首先执行这个函数 ）
//3。如果当前包是main包 ，则定义main函数
//4。然后定义其余的函数，首先是类型的方法，接着按main函数中先后调用的顺序来

//例如
//事实证明 import 不能放在后面 无法识别
//import(
//	"fmt"
//)
const cc = "C"
var v int = 5
type T struct {

}

//init函数
func init(){

}

//main函数

//其他函数


//Go程序的执行（启动）顺序
//1。按顺序导入所有被 main 包引用的其他的包，然后在每个包中执行如下流程
//2。如果该包又导入了其他的包，则回到第一步这样递归执行，但是【注意：每个包只会被导入一次】
//3。然后以相反的顺序（即处于递归深层的包先行初始化）在每个包中初始化常量和变量，如果该包含有init函数，则调用此函数
//4。在完成这一切之后，main包也执行同样的过程，最后调用main函数开始执行程序


//类型转换
//在必要以及可靠的情况下，一个类型的值 可以转换成另一种类型的值，由于Go语言不存在隐式类型类型转换
//因此掺有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看是一种函数）
//valueOfTypeB = typeB(valueOfTypeA)
//类型B的值 = 类型B(类型A的值）
func testChange(){
	a := 2.0
	b := int(a)
	fmt.Print(b)
	//c := (int)a //不合法
	//与C++中的强制类型转换类似
	//但C++中有两种方式
	//int a = (int)6.0 //在Java C++中合法 Go中不合法
	//int a = int(6.6) //C++ Go 合法 Java中不合法

	//但这只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型
	//当从一个取值范围较大的转换到取值范围较小的类型时例如将int32->int16，会发生精度丢失的情况
	//当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行进错误
	//
	//具有相同底层类型的变量之间可以相互转换
	var ca IZ = 5
	c := int(ca)
	d := IZ(c)
	fmt.Print(d)

	//一定注意：没有使用的变量也是一个编译的错误
}

//Go的命名规范：通过gofmt来强制实现统一的代码风格，使用混合着大小写与下划线
//的长名称不行，名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符
//返回某个对象的函数或方法的名称一般都是使用名词没有Get之类，如果用于修改某个对象
//则使用setName，最好不要使用下划线

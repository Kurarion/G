package chapter4

import (
	"fmt"
	"math"
	"math/rand"
	"time"
)

//表达式是一种特定的类型的值
//它可以由其他的值以及运算符组合而成
//每个类型定义了可以和自己结合的运算符的集合
//如果使用了不在这个集合中的运算符，则编译错误

var test_same_name = 1

func TestSameName()  {
	fmt.Println("\n===TestSameName===")
	test_same_name:="abc"
	{
		fmt.Println(test_same_name)
	}
	fmt.Println(test_same_name)
	//暂时不清楚如何访问被屏蔽的变量，也可能没有类似C++中的::全局作用域的语法
}

//一元运算符只可以用于一个值的操作（作为后缀）而二元运算符则可以和两个值或者操作数结合
//注意：Go是强类型语言，因此不会进行隐式转换，在任何不同类型之间的转换都必须显式说明
//因此只有两个类型相同的值才能和二元运算符结合
//Go不存在像C++那样的运算符重载（Java也不支持）,但都支持一般的重载表达式的解析顺序是从左到右
//可以通过括号来提高部分的优先级

//布尔类型bool
//var b bool = true // var b = true
//布尔型的值只可以是常量true和false
//两个类型相同的值可以使用==或!=运算符进行比较并获得一个布尔型的值
//
//Go对于值之间的比较有非常严格的
//只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface）它们也必须都实现了
//相同的接口，如果其中一个值是常量，那么另一个值的类型必须与该常量相兼容，
//如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后 才可以进行比较
//
//布尔型可以使用! && ||结合产生另一个布尔值
//在Go语言中&&与||是具有快捷性质的运算符（短路），当左边已经能够确定整个表达式的值时
//右侧则不会继续运算
//经测试没有& 与 |的运算符

//对于布尔值的好的命名：以is或Is开头

//数字类型
//整型int 与浮点型 float
//Go语言支持整型与浮点型数字，并且原生支持复数，其中位的运算采用补码
//Go也有基于架构的类型，例如：int uint 和 uintptr
//这些类型的长度都是根据运行程序所在的操作系统类型所决定的
//注意
//int与uint在32位操作系统上，均使用4字节（32位），在64位操作系统上使用8字节（64位）
//uintptr的长度被设定为足够存放一个指针即可
//
//注意：Go语言中没有float类型，只有float32与float64，并且没有doubleo类型
//与操作系统架构无关的类型都有固定的大小，并在类型的名称中可以看出
//整数：
//
//int8（-128 -> 127）
//int16（-32768 -> 32767）
//int32（-2,147,483,648 -> 2,147,483,647）
//int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）
//无符号整数：
//
//uint8（0 -> 255）
//uint16（0 -> 65,535）
//uint32（0 -> 4,294,967,295）
//uint64（0 -> 18,446,744,073,709,551,615）
//浮点型（IEEE-754 标准）：
//
//float32（+- 1e-45 -> +- 3.4 * 1e38）
//float64（+- 5 * 1e-324 -> 107 * 1e308）
//int型是计算最快的一种类型
//整型的零值为0  浮点型的零值为0.0
//float32精确到小数点后7位，float64精确到小数点后15位
//注意：由于精度的问题使用==或!=比较浮点数时应当非常小心
//最好在正式使用前测试对于精确度要求较高的运算
//
//应当尽可能使用float64，因为math包中所有有关数学运算的函数都会要求接收这个类型
//可以通过增加前缀0来表示8进制数（如：077），增加前缀0x表示16进制数(如：0xFF)
//以及使用e来表示10的连乘（如：1e3 = 1000）
//可以使用a:=unint64(0)来同时完成类型的转换和赋值操作
//这样的a的类型就是uint64

//Go不允许不同类型之间的混合使用，但是对于常量的类型限制非常少
//因此允许常量之间的混合使用
//例如
//var a int
//a = 15
//var b int32
//b = a+a //编译错误，a是int类型与int32可能不同
//b = b+5 //因为5是常量，所以可以通过编译o
//以上不能通过编译的原因是a不能隐式转换为int32类型，使用显式转换即可
//
//格式化说明符
//%d用于格式化整数（%x和%X用于格式化16进制表示的数字）
//%g用于格式化浮点型（%f输出浮点数，%e输出科学计数表示法）
//%0nd用于规定输出长度为n的整数，其中开头的数字0是必须的
//%n.mg用于表示数字n并精确到小数点后m位，除了使用g之外还可以使用e或f
//例如：使用格式化字符串%5.2e1来输出3.4的结果为3.40e+00
//
//数字值转换
//当进行类型a32bitInt = int32(a32Float)的转换时，小数点后的数字将䘣丢弃
//这种情况一般发生当从取值较大的类型转换为取值范围较小的类型时，或者你可以写一个专门用于处理类型
//函数来确保没有发生精度的丢失
//例子
func Uint8FromInt(n int)(uint8,error){
	if 0<=n&&n<math.MaxInt8 {
		return uint8(n),nil
	}
	return 0,fmt.Errorf("%d is out of the unit8 range",n)
}
func IntFromFloat64(x float64)int32{
	if math.MinInt32<= x && x<=math.MaxInt32{
		//Modf用于分解参数的整数与小数部分
		whole, fraction := math.Modf(x)
		if fraction >= 0.5{
			whole++
			//注意：GO中没有前置的++运算符
		}
		return int32(whole)

	}
	//如果走到这一步说明范围超界，使用panic关键字引发一个panic
	panic(fmt.Sprintf("%g is out of the int32 range",x))
}
//复数
//Go拥有以下复数类型
//complex64 (32位实数与虚数)
//complex128(64位实数和虚数)
//复数使用re+imI来表示 ，其中re代表实数部分， im代表虚数部分, I代表根号负1

//var c1 complex64 = 5 + 10i
//fmt.Printf("The value is: %v", c1)
//输出： 5+ 10i

//如果re和im的类型均为float32那么类型为complex64的复数c可以通过以下方法来获得
//c = complex(re,im)
//函数real(c)和imag(c)可以分别获得相应的实数和虚数部分
//使用%v来表示复数，但希望只表示其中一个部分的时候需要使用&f
//复数支持和其他数字类型一样的运算，使用== !=同样要注意精度问题
//cmath包中包含了一些操作复数的公共方法
//
//位运算
//位运算只能用于整数类型的变量，且需当它们拥有等长位模式时
//%b是用于表示位的格式化标识符
//二元运算符
//按位与&: 对应位置上的值经过和运算结果
//按位或|: 或运算
//按位异或^:
//位清除 &^ :将指定位置上值设置为0
//
//一元运算符
//按位补足^:该运算符与异或运算符一同使用，即m^x，对于无符号x使用“全部位设置为1”
//对于有符号x时使用m=-1
//例如： ^10 = -01^10 = -11
func TestXor(){
	a:=^10 // = -01(二进制) ^ 10
	//也就是说：先让参数与1进行xor最后加上负号
	fmt.Println(a)
}

//位左移
//用法：bitP<<n
//bitP的位向左移动n位，右侧空白部分使用0填充，如果n等于2，则结果是2的相应的位数
//即2的n次方
//  1 << 10 // 等于 1 KB
//  1 << 20 // 等于 1 MB
//  1 << 30 // 等于 1 GB
//位右移>>:
//左侧也是使用0填充，如果n等于2，则结果是当前值除以2的n次方
//可以使用 <<= 或 ^=这样的简写的运算符

//位左移常见实现存储单位的用例
//使用位左移与iota计数配合可优雅实现存储单位的常量枚举
type ByteSize float64
const(
	_ = iota
	KB ByteSize = 1<<(10*iota)
	MB
	GB
	TB
	PB
	EB
)

//在通讯中使用
type BitFlag int
const(
	Active BitFlag = 1 <<iota // 1<<0 ==1
	Send // 1<<1 == 2
	Receive // 1<<2 ==4
)
//flag := Active | Send // ==3

//逻辑运算符
//== != < > <= >=等等
//总是返回布尔值

//算术运算符
//常见的 + - * /
//相对于一般规则，Go在进行字符串拼接时允许使用对+重载，这点与Java类似 但
//注意：Go本身不允许开发者进行自定义的运算符重载
// /运算符对于整数运算而言，结果依旧为整数，例如：9/4 -> 2
//取余运算符只能用于整数： 9%4->1
//整数除以0可能导致程序崩溃，将会导致运行时的恐慌(panic)状态
//如果除以0在编译时能捕捉到，则会引发编译错误
//注意：浮点数除以0.0会返回一个无穷尽的结果，使用+Inf表示

//++ -- 递增 递减只能用于后缀不能像C++那样可以前缀
//注意：同时使用以上两个运算符时只能作为语句。它并不是一个表达式
//因此 n = i++这种写法是无效的
//但Java C++是支持的
//注意：在运算时 溢出 不会产生错误，Go会简单地将超出位数抛弃
//如果你需要范围无限大的整数或有理数，可以使用标准库的big包
//该包提供了类似big.Int和big.Rat这样的类型

//随机数
//rand包实现了伪随机数的生成
func TestRand(){
	for i :=0; i<10;i++{
		a:=rand.Int()
		fmt.Printf("%d / ",a)
		//结果一致，因为没有Seed
	}
	fmt.Println()
	for i:=0;i<5 ;i++  {
		r:=rand.Intn(8)
		fmt.Printf("%d / ",r)
		//结果一致
	}
	fmt.Println()
	timens := int64(time.Now().Nanosecond())
	rand.Seed(timens)
	for i:=0;i<10;i++{
		fmt.Printf("%2.2f / ",100*rand.Float32())
		//结果不一致
	}
}

//rand.Float32与 Float64返回介于[0.0,1.0)之间的伪随机数
//其中包括0.0 不包括1.0
//rand.Intn返回介于{0,n)之间的伪随机数

//使用Seed(value)函数来提供伪随机数的生成种子，一般情况下都使用当前时间的纳秒
//级数字

//运算符与优先级
//二元运算符的运算方向都是从左至右
//优先级 	运算符
// 7 		^ !
// 6 		* / % << >> & &^
// 5 		+ - | ^
// 4 		== != < <= >= >
// 3 		<-
// 2 		&&
// 1 		||

//类型别名
//当在使用某个类型时，可以给它起另一个名字，就可以使用新的名字，心解决名称冲突
type TZZ int
const test_tyep TZZ = 10

//注意：类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法
//TZZ可以自定义一个方法用来输出更加人性化的时区信息

//字符类型
//严格来说，并不是Go语言的一个类型，字符只是整数的特殊用例。byte类型是uint8的别名
//对于只占1个字节的传统ASCII编码的字符来说，完全没有问题
//例如 var ch byte = 'A'；注意：字符使用单引号括起来
//
//在ASCII码表中，A的值是65，而使用16进制表示则为41
//var ch byte = 65
//var ch byte = '\x41'
//\x只是紧跟长度为2的16进制数
//注意：另一种可能的写法是\后面紧跟着长度为3的八进制数例如： \377
//不过Go同样支持UTF-8，因此字符同样称为Unicode代码点或者runes
//并在内存中使用int来表示，在文档中，一般使用格式U+hhhh来表示，其中h表示一个16进制数
//注意：其实rune也是Go当中的一个类型，并且是int32的别名
//注意：与Java有着相似的地方，Java也有专门的处理的Unicode的相关函数，也能将Unicode字符串导出为int值的“流”
//Java也支持从一个int值流创建相对应的Unicode字符串
//在书写Unicode字符时，需要在16进制之前加上前缀\u或\U
//因为Unicode至少占用2个字节，所以我们使用int16或int类型来表示
//如果需要使用4字节，则会加上\U前缀；前缀\u则总是紧跟着长度为4的16进制数（16bit 2字节）
//前缀\U紧跟着长度为8的16进制数（32bit 4字节）

func TestChar (){
	var ch int = '\u0041'
	var ch2 int = '\u03B2'
	var ch3 int = '\U00101234'
	fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
	fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
	fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
	fmt.Printf("%U - %U - %U", ch, ch2, ch3) // UTF-8 code point
}
//输出：
//65 - 946 - 1053236
//A - β - r
//41 - 3B2 - 101234 //16进制
//U+0041 - U+03B2 - U+101234

//格式化说明符%c表示字符
//当和字符配合使用时，%v或%d会输出用于表示 该字符的整数
//注意：%v与类型相关 byte本身是uint8等别名 rune是int32的别名
//注意不是uint32的别名，也许有时取负值对于码点有帮助
//%U输出格式为U+hhhh的字符串

//包unicode包含了一些针对测试字符的非常有用的函数（其中ch代表字符）
//判断是否为字母：unicode.IsLetter(ch)
//判断是否为数字：unicode.IsDigit(ch)
//判断是否为空白符号：unicode.IsSpace(ch)
//这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。
package chapter4

import (
	"fmt"
	"math"
)

//表达式是一种特定的类型的值
//它可以由其他的值以及运算符组合而成
//每个类型定义了可以和自己结合的运算符的集合
//如果使用了不在这个集合中的运算符，则编译错误

var test_same_name = 1

func TestSameName()  {
	fmt.Println("\n===TestSameName===")
	test_same_name:="abc"
	{
		fmt.Println(test_same_name)
	}
	fmt.Println(test_same_name)
	//暂时不清楚如何访问被屏蔽的变量，也可能没有类似C++中的::全局作用域的语法
}

//一元运算符只可以用于一个值的操作（作为后缀）而二元运算符则可以和两个值或者操作数结合
//注意：Go是强类型语言，因此不会进行隐式转换，在任何不同类型之间的转换都必须显式说明
//因此只有两个类型相同的值才能和二元运算符结合
//Go不存在像C++那样的运算符重载（Java也不支持）表达式的解析顺序是从左到右
//可以通过括号来提高部分的优先级

//布尔类型bool
//var b bool = true // var b = true
//布尔型的值只可以是常量true和false
//两个类型相同的值可以使用==或!=运算符进行比较并获得一个布尔型的值
//
//Go对于值之间的比较有非常严格的
//只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface）它们也必须都实现了
//相同的接口，如果其中一个值是常量，那么另一个值的类型必须与该常量相兼容，
//如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后 才可以进行比较
//
//布尔型可以使用! && ||结合产生另一个布尔值
//在Go语言中&&与||是具有快捷性质的运算符（短路），当左边已经能够确定整个表达式的值时
//右侧则不会继续运算
//经测试没有& 与 |的运算符

//对于布尔值的好的命名：以is或Is开头

//数字类型
//整型int 与浮点型 float
//Go语言支持整型与浮点型数字，并且原生支持复数，其中位的运算采用补码
//Go也有基于架构的类型，例如：int uint 和 uintptr
//这些类型的长度都是根据运行程序所在的操作系统类型所决定的
//注意
//int与uint在32位操作系统上，均使用4字节（32位），在64位操作系统上使用8字节（64位）
//uintptr的长度被设定为足够存放一个指针即可
//
//注意：Go语言中没有float类型，只有float32与float64，并且没有doubleo类型
//与操作系统架构无关的类型都有固定的大小，并在类型的名称中可以看出
//整数：
//
//int8（-128 -> 127）
//int16（-32768 -> 32767）
//int32（-2,147,483,648 -> 2,147,483,647）
//int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）
//无符号整数：
//
//uint8（0 -> 255）
//uint16（0 -> 65,535）
//uint32（0 -> 4,294,967,295）
//uint64（0 -> 18,446,744,073,709,551,615）
//浮点型（IEEE-754 标准）：
//
//float32（+- 1e-45 -> +- 3.4 * 1e38）
//float64（+- 5 * 1e-324 -> 107 * 1e308）
//int型是计算最快的一种类型
//整型的零值为0  浮点型的零值为0.0
//float32精确到小数点后7位，float64精确到小数点后15位
//注意：由于精度的问题使用==或!=比较浮点数时应当非常小心
//最好在正式使用前测试对于精确度要求较高的运算
//
//应当尽可能使用float64，因为math包中所有有关数学运算的函数都会要求接收这个类型
//可以通过增加前缀0来表示8进制数（如：077），增加前缀0x表示16进制数(如：0xFF)
//以及使用e来表示10的连乘（如：1e3 = 1000）
//可以使用a:=unint64(0)来同时完成类型的转换和赋值操作
//这样的a的类型就是uint64

//Go不允许不同类型之间的混合使用，但是对于常量的类型限制非常少
//因此允许常量之间的混合使用
//例如
//var a int
//a = 15
//var b int32
//b = a+a //编译错误，a是int类型与int32可能不同
//b = b+5 //因为5是常量，所以可以通过编译o
//以上不能通过编译的原因是a不能隐式转换为int32类型，使用显式转换即可
//
//格式化说明符
//%d用于格式化整数（%x和%X用于格式化16进制表示的数字）
//%g用于格式化浮点型（%f输出浮点数，%e输出科学计数表示法）
//%0nd用于规定输出长度为n的整数，其中开头的数字0是必须的
//%n.mg用于表示数字n并精确到小数点后m位，除了使用g之外还可以使用e或f
//例如：使用格式化字符串%5.2e1来输出3.4的结果为3.40e+00
//
//数字值转换
//当进行类型a32bitInt = int32(a32Float)的转换时，小数点后的数字将䘣丢弃
//这种情况一般发生当从取值较大的类型转换为取值范围较小的类型时，或者你可以写一个专门用于处理类型
//函数来确保没有发生精度的丢失
//例子
func Uint8FromInt(n int)(uint8,error){
	if 0<=n&&n<math.MaxInt8 {
		return uint8(n),nil
	}
	return 0,fmt.Errorf("%d is out of the unit8 range",n)
}
func IntFromFloat64(x float64)int32{
	if math.MinInt32<= x && x<=math.MaxInt32{
		//Modf用于分解参数的整数与小数部分
		whole, fraction := math.Modf(x)
		if fraction >= 0.5{
			whole++
			//注意：GO中没有前置的++运算符
		}
		return int32(whole)

	}
	//如果走到这一步说明范围超界，使用panic关键字引发一个panic
	panic(fmt.Sprintf("%g is out of the int32 range",x))
}
//复数
//Go拥有以下复数类型
//complex64 (32位实数与虚数)
//complex128(64位实数和虚数)
//复数使用re+imI来表示 ，其中re代表实数部分， im代表虚数部分, I代表根号负1

//var c1 complex64 = 5 + 10i
//fmt.Printf("The value is: %v", c1)
//输出： 5+ 10i

//如果re和im的类型均为float32那么类型为complex64的复数c可以通过以下方法来获得
//c = complex(re,im)
//函数real(c)和imag(c)可以分别获得相应的实数和虚数部分
//使用%v来表示复数，但希望只表示其中一个部分的时候需要使用&f
//复数支持和其他数字类型一样的运算，使用== !=同样要注意精度问题
//cmath包中包含了一些操作复数的公共方法
//
//位运算
//位运算只能用于整数类型的变量，且需当它们拥有等长位模式时
//%b是用于表示位的格式化标识符
//二元运算符
//按位与&: 对应位置上的值经过和运算结果
//按位或|: 或运算
//按位异或^:
//位清除 &^ :将指定位置上值设置为0
//
//一元运算符
//按位补足^:该运算符与异或运算符一同使用，即m^x，对于无符号x使用“全部位设置为1”
//对于有符号x时使用m=-1
//例如： ^10 = -01^10 = -11
func TestXor(){
	a:=^10 // = -01(二进制) ^ 10
	//也就是说：先让参数与1进行xor最后加上负号
	fmt.Println(a)
}

//位左移
//用法：bitP<<n
//bitP的位向左移动n位，右侧空白部分使用0填充，如果n等于2，则结果是2的相应的位数
//即2的n次方
//  1 << 10 // 等于 1 KB
//  1 << 20 // 等于 1 MB
//  1 << 30 // 等于 1 GB
//位右移>>:
//左侧也是使用0填充，如果n等于2，则结果是当前值除以2的n次方
//可以使用 <<= 或 ^=这样的简写的运算符

//位左移常见实现存储单位的用例

